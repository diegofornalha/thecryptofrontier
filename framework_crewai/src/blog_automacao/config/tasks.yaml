# Configuração das tarefas para automação de blog de criptomoedas
# ------------------------------------------------------

# Tarefas de monitoramento
monitoring_task:
  description: >
    Monitore os feeds RSS configurados usando a RssFeedTool para encontrar novos artigos sobre criptomoedas.
    IMPORTANTE: Filtre apenas os artigos que não existem no banco de dados. Para cada artigo:
    1. Verifique se o URL do artigo já existe no banco de dados, caso exista, ignore-o.
    2. Um resumo conciso do artigo (max 3 frases)
    3. Os principais tópicos abordados (max 5 tópicos)
    4. Razão pela qual pode ser relevante para investidores brasileiros
    5. Você deve salvar diretamente cada artigo relevante em 'posts_para_traduzir/' em formato JSON.
       Use o nome de arquivo no formato 'para_traduzir_{timestamp}_{fonte}.json', onde:
       - timestamp é o tempo atual no formato YYYYMMDDHHMMSS
       - fonte é um identificador curto da origem do artigo

    Formato de resposta esperado para CADA artigo:
    {{
     "resumo": "Resumo aqui", 
     "topicos": ["tópico 1", "tópico 2", ...], 
     "relevancia": "Explicação da relevância",
     "arquivo_salvo": "caminho do arquivo JSON salvo",
     "original_article": {{ "title": "...", "url": "...", "date": "...", "content": "...", "source": "..." }}
    }}
  expected_output: >
    Uma lista de JSONs, cada um representando um artigo relevante encontrado e salvo, 
    incluindo o caminho do arquivo JSON salvo. Ou uma mensagem indicando que nenhum artigo novo foi encontrado.
  agent: monitor

selection_task:
  description: >
    Avalie a relevância de CADA artigo fornecido pela tarefa anterior para o público brasileiro.
    Input esperado: Uma lista de JSONs (output da monitoring_task).

    Para cada artigo na lista:
    Use os campos "resumo", "topicos", "relevancia" para avaliar.
    Critérios de avaliação:
    1. Relevância para investidores brasileiros
    2. Novidade da informação
    3. Potencial de interesse
    4. Impacto no mercado brasileiro

    Se o artigo for relevante (SIM):
    - Pegue os dados do campo "original_article".
    - Crie um nome de arquivo único (ex: para_traduzir_artigo.json).
    - Salve um arquivo JSON/Markdown em \'posts_para_traduzir/\' contendo os dados originais 
      (título, url, data, conteúdo, fonte) com um frontmatter apropriado.
    - Retorne o caminho completo do arquivo salvo.
    
    Se o artigo NÃO for relevante:
    - Retorne None ou uma string vazia para este artigo.

  expected_output: >
    Uma lista contendo os caminhos dos arquivos salvos em \'posts_para_traduzir\' para os artigos
    selecionados, ou None/vazio para os não selecionados. 
    Ex: ["posts_para_traduzir/arq1.json", null, "posts_para_traduzir/arq3.json"]
  agent: selector
  # Esta tarefa agora é responsável por salvar o arquivo, como faz a lógica de fallback no main.py

# Tarefas de tradução
translation_task:
  description: >
    Traduza o conteúdo do artigo fornecido no arquivo JSON {arquivo_json}.
    O arquivo JSON contém vários campos, incluindo 'content_text_original' e/ou 'content_html_original'.
    Leia o arquivo JSON, identifique o conteúdo principal a ser traduzido (priorize 'content_text_original').

    Siga estas diretrizes:
    1. Traduza o CONTEÚDO identificado do inglês para português brasileiro formal.
    2. Mantenha termos técnicos de cripto quando não houver equivalente em português.
    3. Preserve a formatação se estiver traduzindo conteúdo HTML. Se for texto puro, preserve parágrafos.
    4. Revise e corrija erros gramaticais e ortográficos no texto traduzido.
    5. Melhore a coerência e fluidez do texto.
    6. Adapte o conteúdo para o público brasileiro:
       - Adicione contextualizações relevantes para o mercado brasileiro quando necessário
       - Adapte exemplos para o contexto brasileiro se apropriado
       - Explique conceitos que podem ser menos conhecidos no Brasil
    7. Crie um objeto 'frontmatter_traduzido' que deve conter:
       - title: O título original (de frontmatter_original.title) traduzido e adaptado
       - tags: 5-8 tags relevantes em português
       - category: Classifique o artigo em uma categoria principal (ex: Bitcoin, Ethereum, DeFi, NFTs, Regulamentação, etc.)
       - seo_meta_description: Uma meta descrição otimizada para SEO (máx 160 caracteres) em português
       - published_date: Mantenha a data de 'frontmatter_original.published_date'
       - slug: Gere um novo slug em português a partir do título traduzido
    
    Retorne o OBJETO JSON COMPLETO atualizado com os seguintes campos adicionados:
    - 'content_text_traduzido': contendo a tradução do texto puro, revisada e adaptada.
    - 'content_html_traduzido': contendo a tradução do HTML, revisada e adaptada.
    - 'frontmatter_traduzido': contendo os metadados traduzidos e adaptados.
    
    Para salvar o arquivo:
    1. Gere um nome de arquivo de saída baseado no nome do {arquivo_json} original, 
       substituindo 'para_traduzir_' por 'traduzido_' (mantendo a extensão .json).
    2. Determine o caminho completo de salvamento: o diretório base para salvamento será o diretório pai 
       do diretório 'posts_para_traduzir' que contém o {arquivo_json}. O arquivo deve ser salvo no 
       subdiretório 'posts_traduzidos' dentro deste caminho base. 
       (Ex: se {arquivo_json} é 'pasta_workspace/dir_teste/posts_para_traduzir/original.json', 
       o file_path será 'pasta_workspace/dir_teste/posts_traduzidos/traduzido_original.json').
    3. Serialize o objeto JSON COMPLETO E ATUALIZADO para uma string.
    4. Utilize a ferramenta 'File Save Tool'. Forneça um dicionário como input para a ferramenta contendo:
       - 'file_path': o caminho completo de salvamento determinado no passo 2.
       - 'content': a string JSON serializada do passo 3.
  expected_output: >
    APENAS o CAMINHO COMPLETO (file_path) onde o arquivo JSON foi salvo pela 'File Save Tool'.
    Exemplo: 'src/temp_test_dir_single_post/posts_traduzidos/traduzido_artigo_xyz.json'
  agent: translator
  # Input: {arquivo_json} (caminho do arquivo em posts_para_traduzir)

# Nova tarefa para formatação do JSON para o Sanity
json_formatting_task:
  description: >
    Formate o conteúdo traduzido do arquivo JSON {arquivo_json} para o formato específico do schema Sanity.
    O arquivo JSON contém 'content_text_traduzido', 'content_html_traduzido' e 'frontmatter_traduzido'.
    
    Siga estas diretrizes para criar um documento JSON compatível com o schema do Sanity:
    
    1. Leia o arquivo JSON traduzido e extraia o conteúdo e metadados.
    
    2. Crie um novo objeto JSON com a seguinte estrutura:
       {
         "_type": "post",
         "_id": "drafts.post-YYYYMMDDHHMMSS", (utilize a data atual)
         "title": "Título traduzido do frontmatter",
         "slug": {
           "_type": "slug", 
           "current": "slug-em-portugues"
         },
         "publishedAt": "Data ISO de publicação",
         "excerpt": "Primeiro parágrafo ou resumo do conteúdo (máx 300 caracteres)",
         "content": [ 
           // Array de blocos no formato Portable Text do Sanity
           {
             "_key": "UUID gerado",
             "_type": "block",
             "children": [
               {
                 "_key": "UUID gerado",
                 "_type": "span",
                 "marks": [],
                 "text": "Texto do parágrafo"
               }
             ],
             "markDefs": [],
             "style": "normal" // ou "h1", "h2", "h3", etc. para títulos
           },
           // Mais blocos...
         ],
         "categories": [
           {
             "_type": "reference",
             "_key": "UUID gerado",
             "_ref": "ID da categoria no Sanity"
           }
         ],
         "tags": [
           {
             "_type": "reference",
             "_key": "UUID gerado",
             "_ref": "ID da tag no Sanity"
           }
         ],
         "author": {
           "_type": "reference",
           "_ref": "ID do autor no Sanity"
         },
         "originalSource": {
           "url": "URL original do artigo",
           "title": "Título original",
           "site": "Nome do site de origem"
         }
       }
       
    3. Para gerar o array de blocos "content", divida o conteúdo traduzido em parágrafos e:
       - Para cada parágrafo, crie um objeto de bloco com um "_key" único
       - Identifique cabeçalhos (linhas começando com #, ##, ###) e defina o "style" adequadamente
       - Crie um objeto "span" filho para cada bloco com o texto do parágrafo
       
    4. Para as referências (categorias, tags, autor):
       - Utilizar IDs válidos do Sanity para estas entidades
       - Para categorias e tags, usar os valores do frontmatter_traduzido
       - Para autor, usar um ID padrão (se não especificado)
       
    5. Para o excerpt, use os primeiros 300 caracteres do primeiro parágrafo do conteúdo
    
    6. Salve o objeto JSON formatado em um novo arquivo:
       - Nome do arquivo: substitua "traduzido_" por "formatado_" no nome do arquivo original
       - Diretório: mesmo diretório do arquivo traduzido, mas em uma pasta "posts_formatados"
       - Utilize a ferramenta 'File Save Tool' para salvar
    
  expected_output: >
    APENAS o CAMINHO COMPLETO (file_path) onde o arquivo JSON formatado foi salvo pela 'File Save Tool'.
    Exemplo: '/src/temp_test_dir_single_post/posts_formatados/formatado_artigo_xyz.json'
  agent: json_formatter
  context:
    - translation_task

# Tarefa de Edição (Movida para cima)
editing_task:
  description: >
    Revise e melhore o artigo traduzido e adaptado, fornecido como um objeto JSON (resultado da tarefa de tradução).
    O objeto JSON contém campos como 'content_text_traduzido', 'content_html_traduzido', e o 'frontmatter_original'.
    Você também tem acesso ao caminho do arquivo JSON original via {arquivo_json} se precisar de metadados extras.

    Siga estas diretrizes:
    1. Corrija erros gramaticais e ortográficos em 'content_text_traduzido'.
    2. Melhore a coerência e fluidez do texto em 'content_text_traduzido'.
    3. Verifique a precisão das informações técnicas.
    4. Garanta que o tom seja adequado ao público-alvo.
    
    Retorne o OBJETO JSON COMPLETO E ATUALIZADO. Este objeto será então passado para a tarefa de localização.
  expected_output: >
    Uma string representando o objeto JSON COMPLETO E ATUALIZADO, com o conteúdo revisado.
  agent: editor
  context: 
    - translation_task

localization_task:
  description: >
    Adapte o artigo traduzido, fornecido como um objeto JSON (resultado da tarefa anterior), para o público brasileiro.
    O objeto JSON contém campos como 'content_text_traduzido', 'content_html_traduzido', e 'frontmatter_original'.
    Você também tem acesso ao caminho do arquivo JSON original via {arquivo_json} se precisar de metadados extras.
    
    Siga estas diretrizes:
    1. Analise o CONTEÚDO em 'content_text_traduzido'.
    2. Adicione contextualizações relevantes para o mercado brasileiro quando necessário.
    3. Adapte exemplos para o contexto brasileiro se apropriado.
    4. Explique conceitos que podem ser menos conhecidos no Brasil.
    5. Mantenha o tom e estilo do artigo original.
    6. O resultado da adaptação deve ser uma string (texto puro ou HTML, conforme o conteúdo traduzido).
    7. Crie um novo objeto 'frontmatter_traduzido' dentro do JSON. Ele deve conter:
       - title: O título original (de frontmatter_original.title) traduzido e adaptado.
       - tags: 5-8 tags relevantes em português.
       - category: Classifique o artigo em uma categoria principal (ex: Bitcoin, Ethereum, DeFi, NFTs, Regulamentação, etc.)
       - seo_meta_description: Uma meta descrição otimizada para SEO (máx 160 caracteres) em português.
       - published_date: Mantenha a data de 'frontmatter_original.published_date'.
       - slug: Gere um novo slug em português a partir do título traduzido.

    Atualize o objeto JSON recebido: 
    - Modifique 'content_text_traduzido' e/ou 'content_html_traduzido' com o conteúdo adaptado.
    - Adicione o novo 'frontmatter_traduzido'.
    
    Para salvar o arquivo:
    1. Gere um nome de arquivo de saída baseado no nome do {arquivo_json} original, 
       substituindo 'para_traduzir_' por 'traduzido_' (mantendo a extensão .json).
    2. Determine o caminho completo de salvamento: o diretório base para salvamento será o diretório pai 
       do diretório 'posts_para_traduzir' que contém o {arquivo_json}. O arquivo deve ser salvo no 
       subdiretório 'posts_traduzidos' dentro deste caminho base. 
       (Ex: se {arquivo_json} é 'pasta_workspace/dir_teste/posts_para_traduzir/original.json', 
       o file_path será 'pasta_workspace/dir_teste/posts_traduzidos/traduzido_original.json').
    3. Serialize o objeto JSON COMPLETO E ATUALIZADO para uma string.
    4. Utilize a ferramenta 'File Save Tool'. Forneça um dicionário como input para a ferramenta contendo:
       - 'file_path': o caminho completo de salvamento determinado no passo 2.
       - 'content': a string JSON serializada do passo 3.
    
  expected_output: >
    APENAS o CAMINHO COMPLETO (file_path) onde o arquivo JSON foi salvo pela 'File Save Tool'.
    Exemplo: '/src/temp_test_dir_single_post/posts_traduzidos/traduzido_artigo_xyz.json'
  agent: localizer
  context: 
    - editing_task # Agora editing_task está definida acima

# Tarefas de publicação
seo_optimization_task:
  description: >
    Otimize o artigo traduzido (recebido como um objeto JSON da tarefa anterior, ou lido do arquivo JSON {arquivo_json}) para SEO
    e prepare um payload para o Sanity CMS.
    O objeto/arquivo JSON contém 'content_text_traduzido', 'content_html_traduzido' e 'frontmatter_traduzido'.
    
    Siga estas diretrizes:
    1. Analise o 'content_text_traduzido' e o 'frontmatter_traduzido.title'.
    2. Identifique 3-5 palavras-chave principais.
    3. Otimize o 'frontmatter_traduzido.title' para SEO (mantendo significado).
    4. Verifique a densidade de palavras-chave no 'content_text_traduzido'.
    5. Crie/Atualize a 'frontmatter_traduzido.seo_meta_description' (máx 160 caracteres).
    6. Baseado no 'frontmatter_traduzido' otimizado, construa um novo objeto chamado 'sanity_document_payload'. Este objeto deve conter:
       - _type: "post" (ou o tipo de schema que você usa no Sanity para posts)
       - title: (string) O título otimizado de 'frontmatter_traduzido.title'.
       - slug: (object) Um objeto com formato {"_type": "slug", "current": "slug-gerado-a-partir-do-titulo-otimizado"}.
       - tags: (array de strings) As tags de 'frontmatter_traduzido.tags'.
       - categories: (array de strings) A categoria de 'frontmatter_traduzido.category' (coloque-a dentro de um array, ex: ["Nome da Categoria"]). A SanityPublishTool pode precisar resolver isso para referências se necessário.
       - seo: (object) Um objeto com {"meta_title": "título otimizado", "meta_description": "meta descrição otimizada"}.
       - publishedAt: (string) A data de 'frontmatter_traduzido.published_date'.
       - Mais campos podem ser adicionados aqui se fizerem parte do seu schema Sanity para metadados (ex: autor, imagem principal se tiver essa info).
    
    Mantenha os campos 'content_text_traduzido' e 'content_html_traduzido' no nível raiz do JSON retornado, 
    juntamente com o novo objeto 'sanity_document_payload'.
  expected_output: >
    Uma string representando um NOVO objeto JSON contendo APENAS os campos 'sanity_document_payload', 
    'content_text_traduzido', e 'content_html_traduzido'.
  agent: seo_analyst
  context: 
    - translation_task

publish_task:
  description: >
    Publique o artigo pré-formatado no Sanity CMS.
    O arquivo JSON {arquivo_json} contém o documento já formatado de acordo com o schema do Sanity.
    
    Siga estas etapas:
    1. Leia o arquivo JSON formatado completo.
    2. Verifique se o formato JSON corresponde exatamente ao schema do Sanity:
       - Todos os campos obrigatórios estão presentes (_type, title, slug, content, etc.)
       - As referências (tags, categorias, autor) estão no formato correto
       - Os blocos de conteúdo estão formatados corretamente como Portable Text
       - Todos os campos têm os tipos de dados corretos
    
    3. Use a ferramenta 'SanityPublishTool' para publicar o documento, enviando o objeto JSON
       completo exatamente como está no arquivo formatado.
    
    4. Após a publicação bem-sucedida, mova o arquivo de posts_formatados para posts_publicados,
       alterando o prefixo de "formatado_" para "publicado_".
    
  expected_output: >
    Um objeto com informações sobre o resultado da publicação, incluindo:
    - "success": true/false
    - "document_id": ID do documento publicado (se bem-sucedido)
    - "url": URL do post publicado (se disponível)
    - "arquivo_publicado": Caminho do arquivo movido para posts_publicados (se aplicável)
  agent: publisher
  context: 
    - json_formatting_task # Agora depende da tarefa de formatação JSON

# Nova tarefa de detecção e remoção de duplicatas
duplicate_detection_task:
  description: >
    Analise os últimos 20 artigos publicados no Sanity CMS e identifique possíveis duplicatas.
    
    Siga estas diretrizes:
    1. Use a ferramenta 'DuplicateDetectorTool' para verificar os últimos 20 artigos publicados.
    2. Configure o parâmetro 'action' da ferramenta:
       - Primeiro faça uma análise usando 'action="detect"' para apenas listar duplicatas.
       - Se encontrar duplicatas, determine se devem ser removidas com base nestas regras:
         a) Se os artigos têm exatamente o mesmo título, remova o mais recente.
         b) Se os artigos têm títulos muito similares (diferindo apenas em capitalização ou pontuação), remova o mais recente.
    3. Se a decisão for remover artigos duplicados, execute a ferramenta novamente com 'action="remove"'.
    4. Limite a análise aos últimos 20 artigos por padrão, ou ao número especificado em {limit} se fornecido.
    
    IMPORTANTE: Antes de remover qualquer artigo:
    - Documente claramente qual artigo será removido e por quê.
    - Inclua os IDs e títulos dos artigos envolvidos.
    - Justifique a decisão de remoção baseada nas regras acima.
    
    Esta tarefa deve ser executada:
    - Após cada ciclo de publicação de novos artigos
    - Periodicamente (uma vez por dia) para garantir que não existam duplicatas
    
    A ferramenta irá verificar o título dos artigos para identificar duplicatas. 
    Artigos são considerados duplicados se tiverem o mesmo título (ignorando diferenças de capitalização e espaços).
  expected_output: >
    Um relatório detalhado sobre os artigos duplicados encontrados e a ação tomada para cada um,
    no formato JSON com as seguintes informações:
    {
      "verificados": número de artigos analisados,
      "duplicatas_encontradas": número de duplicatas encontradas,
      "duplicatas_removidas": número de duplicatas efetivamente removidas,
      "detalhes": [
        {
          "id": ID do artigo duplicado,
          "título": título do artigo,
          "duplicata_de": {
            "id": ID do artigo original,
            "título": título do artigo original
          },
          "removido": true/false,
          "justificativa": razão da remoção ou não remoção
        },
        ...
      ]
    }
  agent: duplicate_detector
